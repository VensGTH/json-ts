"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JsonProperty = JsonProperty;
exports.deserialize = deserialize;
exports.serialize = serialize;
exports.DecoratorMetaData = void 0;

require("reflect-metadata");

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
* Decorator variable name
*
* @const
*/
var METADATA_KEY = 'JsonProperty';
/**
* When custom mapping of a property is required.
*
* @interface
*/

/**
* DecoratorMetaData
* Model used for decoration parameters
*
* @class
* @property {string} name, indicate which json property needed to map
* @property {string} type, if the target is not primitive type, map it to corresponding class
*/
var DecoratorMetaData = function DecoratorMetaData(name, type) {
  _classCallCheck(this, DecoratorMetaData);

  this.name = name;
  this.type = type;
};
/**
* JsonProperty
*
* @function
* @param {IDecoratorMetaData<T>|string} metadata Encapsulate it to DecoratorMetaData for standard use
* @return {(target: object, targetKey: string | symbol) => void} Decorator function
*/


exports.DecoratorMetaData = DecoratorMetaData;

function JsonProperty(metadata) {
  if (!['string', 'object'].some(function (value) {
    return _typeof(metadata) === value;
  })) {
    throw new Error('JsonProperty decorator options must be of type \'string\' or \'IDecoratorMetaData\'!');
  }

  var decorator = typeof metadata === 'string' ? new DecoratorMetaData(metadata) : metadata;
  return Reflect.metadata(METADATA_KEY, decorator);
}

function deserializeProp(metadata, instance, json, key) {
  var index = metadata.name || key;
  var value = json ? json[index] : null;
  var options = Reflect.getMetadata(METADATA_KEY, instance, key);
  var type = Reflect.getMetadata('design:type', instance, key) || options.type;

  if (type == undefined) {
    return json[index];
  }

  if (Array.isArray(type) || type === Array) {
    if (options && options.type || _typeof(type) === 'object') {
      if (value && Array.isArray(value)) {
        return value.map(function (item) {
          return deserialize(options.type, item);
        });
      }

      return;
    } else {
      return value;
    }
  }

  if (!isPrimitive(type) && _typeof(value) === 'object' && !Array.isArray(value)) {
    return deserialize(type, value);
  }

  if (type === Boolean) {
    if (json[index] === undefined) {
      return undefined;
    }

    return Boolean(json[index]);
  }

  return json[index];
}
/**
* deserialize
*
* @function
* @param {{new():T}} type, class type which is going to initialize and hold a mapping json
* @param {Object} json, input json object which to be mapped
*
* @return {T} return mapped object
*/


function deserialize(type, json) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  if (type == undefined || json == undefined) {
    return undefined;
  }

  if (_typeof(json) !== 'object') {
    return undefined;
  }

  if (Array.isArray(json)) {
    return json.map(function (value) {
      return deserialize(type, value);
    });
  }

  var instance = args.length > 0 ? _construct(type, args) : new type();
  Object.keys(instance).forEach(function (key) {
    var metadata = Reflect.getMetadata(METADATA_KEY, instance, key);
    var value = metadata ? metadata.converter ? metadata.converter.fromJson(json[metadata.name || key]) : deserializeProp(metadata, instance, json, key) : json[key] || instance[key];
    instance[key] = value;
  });
  return instance;
}
/**
* Serialize: Creates a JSON serializable object from the provided object instance.
* Only @JsonProperty decorated properties in the model instance are processed.
*
*/


function serialize(instance) {
  if (Array.isArray(instance)) {
    return instance.map(function (value) {
      return serialize(value);
    });
  }

  var obj = Object.create(null);
  Object.keys(instance).forEach(function (key) {
    var metadata = Reflect.getMetadata(METADATA_KEY, instance, key);
    obj[metadata && metadata.name ? metadata.name : key] = serializeProperty(metadata, instance[key]);
  });
  return obj;
}
/**
* Prepare a single property to be serialized to JSON.
*
* @param metadata
* @param prop
* @returns {any}
*/


function serializeProperty(metadata, prop) {
  if (prop == undefined) {
    return prop;
  }

  if (!metadata || metadata.exclude === true) {
    return;
  }

  if (metadata.converter) {
    return metadata.converter.toJson(prop);
  }

  if (!metadata.type) {
    return prop instanceof Date ? new Date(prop.getTime() - prop.getTimezoneOffset() * 60000).toISOString() : prop;
  }

  if (Array.isArray(prop)) {
    return prop.map(function (item) {
      return serialize(item);
    });
  }

  return serialize(prop);
}

function isPrimitive(obj) {
  return !!(['string', 'boolean', 'number'].indexOf(_typeof(obj)) > -1 || obj instanceof String || obj === String || obj instanceof Number || obj === Number || obj instanceof Boolean || obj === Boolean);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC50cyJdLCJuYW1lcyI6WyJNRVRBREFUQV9LRVkiLCJEZWNvcmF0b3JNZXRhRGF0YSIsIm5hbWUiLCJ0eXBlIiwiSnNvblByb3BlcnR5IiwibWV0YWRhdGEiLCJzb21lIiwidmFsdWUiLCJFcnJvciIsImRlY29yYXRvciIsIlJlZmxlY3QiLCJkZXNlcmlhbGl6ZVByb3AiLCJpbnN0YW5jZSIsImpzb24iLCJrZXkiLCJpbmRleCIsIm9wdGlvbnMiLCJnZXRNZXRhZGF0YSIsInVuZGVmaW5lZCIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIml0ZW0iLCJkZXNlcmlhbGl6ZSIsImlzUHJpbWl0aXZlIiwiQm9vbGVhbiIsImFyZ3MiLCJsZW5ndGgiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImNvbnZlcnRlciIsImZyb21Kc29uIiwic2VyaWFsaXplIiwib2JqIiwiY3JlYXRlIiwic2VyaWFsaXplUHJvcGVydHkiLCJwcm9wIiwiZXhjbHVkZSIsInRvSnNvbiIsIkRhdGUiLCJnZXRUaW1lIiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJ0b0lTT1N0cmluZyIsImluZGV4T2YiLCJTdHJpbmciLCJOdW1iZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7O0FBWUE7Ozs7O0FBS0EsSUFBTUEsWUFBWSxHQUFHLGNBQXJCO0FBRUE7Ozs7OztBQXlCQTs7Ozs7Ozs7SUFRYUMsaUIsR0FDWCwyQkFBMEJDLElBQTFCLEVBQStDQyxJQUEvQyxFQUFtRjtBQUFBOztBQUFBO0FBQUE7QUFDbEYsQztBQUdIOzs7Ozs7Ozs7OztBQU9PLFNBQVNDLFlBQVQsQ0FBeUJDLFFBQXpCLEVBQTBIO0FBQy9ILE1BQUksQ0FBQyxDQUFDLFFBQUQsRUFBVyxRQUFYLEVBQXFCQyxJQUFyQixDQUEwQixVQUFBQyxLQUFLO0FBQUEsV0FBSSxRQUFPRixRQUFQLE1BQW9CRSxLQUF4QjtBQUFBLEdBQS9CLENBQUwsRUFBb0U7QUFDbEUsVUFBTSxJQUFJ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LFNBQVMsQ0FBQ1gsSUFBRCxDQUF4QjtBQUFBLEtBQVQsQ0FBUDtBQUNEOztBQUVELFNBQU9XLFNBQVMsQ0FBQ0ksSUFBRCxDQUFoQjtBQUNEOztBQUVELFNBQVNiLFdBQVQsQ0FBcUJVLEdBQXJCLEVBQWtJO0FBQ2hJLFNBQU8sQ0FBQyxFQUFFLENBQUMsUUFBRCxFQUFXLFNBQVgsRUFBc0IsUUFBdEIsRUFBZ0NVLE9BQWhDLFNBQWdEVixHQUFoRCxLQUF3RCxDQUFDLENBQXpELElBQStEQSxHQUFHLFlBQVlXLE1BQWYsSUFBeUJYLEdBQUcsS0FBS1csTUFBakMsSUFDekVYLEdBQUcsWUFBWVksTUFEMEQsSUFDaERaLEdBQUcsS0FBS1ksTUFEd0MsSUFFekVaLEdBQUcsWUFBWVQsT0FGMEQsSUFFL0NTLEdBQUcsS0FBS1QsT0FGMUIsQ0FBUjtBQUdEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdyZWZsZWN0LW1ldGFkYXRhJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSlNPTk9iamVjdCB7XHJcbiAgW2tleTogc3RyaW5nXTogSlNPTlR5cGU7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIEpTT05UeXBlID0gc3RyaW5nIHwgbnVtYmVyIHwgSlNPTkFycmF5IHwgSlNPTk9iamVjdCB8IGJvb2xlYW4gfCBudWxsO1xyXG5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbmV4cG9ydCBpbnRlcmZhY2UgSlNPTkFycmF5IGV4dGVuZHMgQXJyYXk8SlNPTlR5cGU+IHt9XHJcblxyXG5cclxuLyoqXHJcbiogRGVjb3JhdG9yIHZhcmlhYmxlIG5hbWVcclxuKlxyXG4qIEBjb25zdFxyXG4qL1xyXG5jb25zdCBNRVRBREFUQV9LRVkgPSAnSnNvblByb3BlcnR5JztcclxuXHJcbi8qKlxyXG4qIFdoZW4gY3VzdG9tIG1hcHBpbmcgb2YgYSBwcm9wZXJ0eSBpcyByZXF1aXJlZC5cclxuKlxyXG4qIEBpbnRlcmZhY2VcclxuKi9cclxuZXhwb3J0IGludGVyZmFjZSBJQ3VzdG9tQ29udmVydGVyPFQ+IHtcclxuICBmcm9tSnNvbihkYXRhOiBhbnkpOiBUO1xyXG4gIHRvSnNvbihkYXRhOiBUKTogYW55O1xyXG59XHJcblxyXG4vKipcclxuKiBJRGVjb3JhdG9yTWV0YURhdGE8VD5cclxuKiBEZWNvcmF0b3JDb25zdHJhaW50XHJcbipcclxuKiBAaW50ZXJmYWNlXHJcbiogQHByb3BlcnR5IHtJQ3VzdG9tQ29udmVydGVyfSBjb252ZXJ0ZXIsIFVzZWQgZm9yIG1hcHBpbmcgdGhlIHByb3BlcnR5LCBpZiBzcGVjaWZpZWRcclxuKiBAcHJvcGVydHkge2Jvb2xlYW59IGV4Y2x1ZGUsIEV4Y2x1ZGUgdGhlIHByb3BlcnR5IGZvciBzZXJpYWxpemF0aW9uXHJcbiovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSURlY29yYXRvck1ldGFEYXRhPFQ+IHtcclxuICBuYW1lPzogc3RyaW5nO1xyXG4gIHR5cGU/OiB7IG5ldyAoLi4uYXJnczogYW55W10pOiBUIH07XHJcbiAgY29udmVydGVyPzogSUN1c3RvbUNvbnZlcnRlcjxUPjtcclxuICBleGNsdWRlPzogYm9vbGVhbjtcclxufVxyXG5cclxuLyoqXHJcbiogRGVjb3JhdG9yTWV0YURhdGFcclxuKiBNb2RlbCB1c2VkIGZvciBkZWNvcmF0aW9uIHBhcmFtZXRlcnNcclxuKlxyXG4qIEBjbGFzc1xyXG4qIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lLCBpbmRpY2F0ZSB3aGljaCBqc29uIHByb3BlcnR5IG5lZWRlZCB0byBtYXBcclxuKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSwgaWYgdGhlIHRhcmdldCBpcyBub3QgcHJpbWl0aXZlIHR5cGUsIG1hcCBpdCB0byBjb3JyZXNwb25kaW5nIGNsYXNzXHJcbiovXHJcbmV4cG9ydCBjbGFzcyBEZWNvcmF0b3JNZXRhRGF0YTxUPiBpbXBsZW1lbnRzIElEZWNvcmF0b3JNZXRhRGF0YTxUPiB7XHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyBuYW1lOiBzdHJpbmcsIHB1YmxpYyB0eXBlPzogeyBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVCB9KSB7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuKiBKc29uUHJvcGVydHlcclxuKlxyXG4qIEBmdW5jdGlvblxyXG4qIEBwYXJhbSB7SURlY29yYXRvck1ldGFEYXRhPFQ+fHN0cmluZ30gbWV0YWRhdGEgRW5jYXBzdWxhdGUgaXQgdG8gRGVjb3JhdG9yTWV0YURhdGEgZm9yIHN0YW5kYXJkIHVzZVxyXG4qIEByZXR1cm4geyh0YXJnZXQ6IG9iamVjdCwgdGFyZ2V0S2V5OiBzdHJpbmcgfCBzeW1ib2wpID0+IHZvaWR9IERlY29yYXRvciBmdW5jdGlvblxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gSnNvblByb3BlcnR5PFQ+KG1ldGFkYXRhPzogSURlY29yYXRvck1ldGFEYXRhPFQ+IHwgc3RyaW5nKTogKHRhcmdldDogb2JqZWN0LCB0YXJnZXRLZXk6IHN0cmluZyB8IHN5bWJvbCkgPT4gdm9pZCB7XHJcbiAgaWYgKCFbJ3N0cmluZycsICdvYmplY3QnXS5zb21lKHZhbHVlID0+IHR5cGVvZiBtZXRhZGF0YSA9PT0gdmFsdWUpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0pzb25Qcm9wZXJ0eSBkZWNvcmF0b3Igb3B0aW9ucyBtdXN0IGJlIG9mIHR5cGUgXFwnc3RyaW5nXFwnIG9yIFxcJ0lEZWNvcmF0b3JNZXRhRGF0YVxcJyEnKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGRlY29yYXRvciA9IHR5cGVvZiBtZXRhZGF0YSA9PT0gJ3N0cmluZycgPyBuZXcgRGVjb3JhdG9yTWV0YURhdGE8VD4obWV0YWRhdGEpIDogbWV0YWRhdGE7XHJcblxyXG4gIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKE1FVEFEQVRBX0tFWSwgZGVjb3JhdG9yKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVzZXJpYWxpemVQcm9wPFQ+KG1ldGFkYXRhOiBJRGVjb3JhdG9yTWV0YURhdGE8YW55PiwgaW5zdGFuY2U6IFQsIGpzb246IEpTT05PYmplY3QsIGtleTogc3RyaW5nKTogYW55IHtcclxuICBjb25zdCBpbmRleCA9IG1ldGFkYXRhLm5hbWUgfHwga2V5O1xyXG4gIGNvbnN0IHZhbHVlOiBKU09OVHlwZSA9IGpzb24gPyBqc29uW2luZGV4XSA6IG51bGw7XHJcblxyXG4gIGNvbnN0IG9wdGlvbnM6IElEZWNvcmF0b3JNZXRhRGF0YTxhbnk+ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShNRVRBREFUQV9LRVksIGluc3RhbmNlLCBrZXkpO1xyXG4gIGNvbnN0IHR5cGU6IGFueSA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgaW5zdGFuY2UsIGtleSkgfHwgb3B0aW9ucy50eXBlO1xyXG5cclxuICBpZiAodHlwZSA9PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBqc29uW2luZGV4XTtcclxuICB9XHJcblxyXG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpIHx8IHR5cGUgPT09IEFycmF5KSB7XHJcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGlmICh2YWx1ZSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKGl0ZW06IGFueSkgPT4gZGVzZXJpYWxpemUob3B0aW9ucy50eXBlLCBpdGVtKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKCFpc1ByaW1pdGl2ZSh0eXBlKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIGRlc2VyaWFsaXplKHR5cGUsIHZhbHVlKTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlID09PSBCb29sZWFuKSB7XHJcbiAgICBpZiAoanNvbltpbmRleF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBCb29sZWFuKGpzb25baW5kZXhdKTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGpzb25baW5kZXhdO1xyXG59XHJcblxyXG4vKipcclxuKiBkZXNlcmlhbGl6ZVxyXG4qXHJcbiogQGZ1bmN0aW9uXHJcbiogQHBhcmFtIHt7bmV3KCk6VH19IHR5cGUsIGNsYXNzIHR5cGUgd2hpY2ggaXMgZ29pbmcgdG8gaW5pdGlhbGl6ZSBhbmQgaG9sZCBhIG1hcHBpbmcganNvblxyXG4qIEBwYXJhbSB7T2JqZWN0fSBqc29uLCBpbnB1dCBqc29uIG9iamVjdCB3aGljaCB0byBiZSBtYXBwZWRcclxuKlxyXG4qIEByZXR1cm4ge1R9IHJldHVybiBtYXBwZWQgb2JqZWN0XHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZTxULCBVIGV4dGVuZHMgSlNPTk9iamVjdCB8IEpTT05BcnJheSA9IEpTT05PYmplY3Q+KHR5cGU6IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQgfSwganNvbjogVSwgLi4uYXJnczogYW55W10pOiBVIGV4dGVuZHMgSlNPTk9iamVjdCA/IFQgOiBUW107XHJcbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZTxUPih0eXBlOiB7IG5ldyAoLi4uYXJnczogYW55W10pOiBUIH0sIGpzb246IEpTT05PYmplY3QgfCBKU09OQXJyYXksIC4uLmFyZ3M6IGFueVtdKTogVCB8IFRbXSB7XHJcbiAgaWYgKHR5cGUgPT0gdW5kZWZpbmVkIHx8IGpzb24gPT0gdW5kZWZpbmVkKSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBqc29uICE9PSAnb2JqZWN0Jykge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XHJcbiAgICByZXR1cm4ganNvbi5tYXAoKHZhbHVlOiBKU09OT2JqZWN0KSA9PiBkZXNlcmlhbGl6ZSh0eXBlLCB2YWx1ZSkpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaW5zdGFuY2UgPSBhcmdzLmxlbmd0aCA+IDAgPyBuZXcgdHlwZSguLi5hcmdzKSA6IG5ldyB0eXBlKCk7XHJcbiAgXHJcbiAgT2JqZWN0LmtleXMoaW5zdGFuY2UpLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiB7XHJcbiAgICBjb25zdCBtZXRhZGF0YTogSURlY29yYXRvck1ldGFEYXRhPFQ+ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShNRVRBREFUQV9LRVksIGluc3RhbmNlLCBrZXkpO1xyXG5cclxuICAgIGNvbnN0IHZhbHVlID0gbWV0YWRhdGEgPyBtZXRhZGF0YS5jb252ZXJ0ZXIgPyBtZXRhZGF0YS5jb252ZXJ0ZXIuZnJvbUpzb24oanNvblttZXRhZGF0YS5uYW1lIHx8IGtleV0pIDogZGVzZXJpYWxpemVQcm9wKG1ldGFkYXRhLCBpbnN0YW5jZSwganNvbiwga2V5KSA6IGpzb25ba2V5XSB8fCBpbnN0YW5jZVtrZXldO1xyXG5cclxuICAgIGluc3RhbmNlW2tleV0gPSB2YWx1ZTsgICAgXHJcbiAgfSk7XHJcbiAgXHJcbiAgcmV0dXJuIGluc3RhbmNlO1xyXG59XHJcblxyXG4vKipcclxuKiBTZXJpYWxpemU6IENyZWF0ZXMgYSBKU09OIHNlcmlhbGl6YWJsZSBvYmplY3QgZnJvbSB0aGUgcHJvdmlkZWQgb2JqZWN0IGluc3RhbmNlLlxyXG4qIE9ubHkgQEpzb25Qcm9wZXJ0eSBkZWNvcmF0ZWQgcHJvcGVydGllcyBpbiB0aGUgbW9kZWwgaW5zdGFuY2UgYXJlIHByb2Nlc3NlZC5cclxuKlxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplPFQgZXh0ZW5kcyBvYmplY3QgPSBhbnksIFUgZXh0ZW5kcyBvYmplY3QgPSBhbnk+KGluc3RhbmNlOiBUIHwgVFtdKTogVCBleHRlbmRzIGFueVtdID8gVVtdIDogVTtcclxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZTxUIGV4dGVuZHMgb2JqZWN0ID0gYW55LCBVIGV4dGVuZHMgb2JqZWN0ID0gYW55PihpbnN0YW5jZTogVCB8IFRbXSk6IFUgfCBVW10ge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KGluc3RhbmNlKSkge1xyXG4gICAgcmV0dXJuIGluc3RhbmNlLm1hcCgodmFsdWU6IFQpID0+IHNlcmlhbGl6ZSh2YWx1ZSkpO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBvYmo6IFUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIE9iamVjdC5rZXlzKGluc3RhbmNlKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICBjb25zdCBtZXRhZGF0YTogSURlY29yYXRvck1ldGFEYXRhPFQ+ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShNRVRBREFUQV9LRVksIGluc3RhbmNlLCBrZXkpO1xyXG4gICAgb2JqW21ldGFkYXRhICYmIG1ldGFkYXRhLm5hbWUgPyBtZXRhZGF0YS5uYW1lIDoga2V5XSA9IHNlcmlhbGl6ZVByb3BlcnR5KG1ldGFkYXRhLCBpbnN0YW5jZVtrZXldKTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiogUHJlcGFyZSBhIHNpbmdsZSBwcm9wZXJ0eSB0byBiZSBzZXJpYWxpemVkIHRvIEpTT04uXHJcbipcclxuKiBAcGFyYW0gbWV0YWRhdGFcclxuKiBAcGFyYW0gcHJvcFxyXG4qIEByZXR1cm5zIHthbnl9XHJcbiovXHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZVByb3BlcnR5KG1ldGFkYXRhOiBJRGVjb3JhdG9yTWV0YURhdGE8YW55PiwgcHJvcDogYW55KTogYW55IHtcclxuICBpZiAocHJvcCA9PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBwcm9wO1xyXG4gIH1cclxuICBcclxuICBpZiAoIW1ldGFkYXRhIHx8IG1ldGFkYXRhLmV4Y2x1ZGUgPT09IHRydWUpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgXHJcbiAgaWYgKG1ldGFkYXRhLmNvbnZlcnRlcikge1xyXG4gICAgcmV0dXJuIG1ldGFkYXRhLmNvbnZlcnRlci50b0pzb24ocHJvcCk7XHJcbiAgfVxyXG4gIFxyXG4gIGlmICghbWV0YWRhdGEudHlwZSkge1xyXG4gICAgcmV0dXJuIHByb3AgaW5zdGFuY2VvZiBEYXRlID8gbmV3IERhdGUocHJvcC5nZXRUaW1lKCkgLSAocHJvcC5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApKS50b0lTT1N0cmluZygpIDogcHJvcDtcclxuICB9XHJcbiAgXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcCkpIHtcclxuICAgIHJldHVybiBwcm9wLm1hcCgoaXRlbTogYW55KSA9PiBzZXJpYWxpemUoaXRlbSkpO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gc2VyaWFsaXplKHByb3ApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmo6IHVua25vd24pOiBvYmogaXMgc3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlciB8IE51bWJlckNvbnN0cnVjdG9yIHwgU3RyaW5nQ29uc3RydWN0b3IgfCBCb29sZWFuQ29uc3RydWN0b3Ige1xyXG4gIHJldHVybiAhIShbJ3N0cmluZycsICdib29sZWFuJywgJ251bWJlciddLmluZGV4T2YoKHR5cGVvZiBvYmopKSA+IC0xIHx8IChvYmogaW5zdGFuY2VvZiBTdHJpbmcgfHwgb2JqID09PSBTdHJpbmcgfHxcclxuICBvYmogaW5zdGFuY2VvZiBOdW1iZXIgfHwgb2JqID09PSBOdW1iZXIgfHxcclxuICBvYmogaW5zdGFuY2VvZiBCb29sZWFuIHx8IG9iaiA9PT0gQm9vbGVhbikpO1xyXG59XHJcbiJdfQ==