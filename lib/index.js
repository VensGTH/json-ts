"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JsonProperty = JsonProperty;
exports.deserialize = deserialize;
exports.serialize = serialize;
exports.DecoratorMetaData = void 0;

require("reflect-metadata");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
* Decorator variable name
*
* @const
*/
var METADATA_KEY = 'JsonProperty';
/**
* When custom mapping of a property is required.
*
* @interface
*/

/**
* DecoratorMetaData
* Model used for decoration parameters
*
* @class
* @property {string} name, indicate which json property needed to map
* @property {string} type, if the target is not primitive type, map it to corresponding class
*/
var DecoratorMetaData = function DecoratorMetaData(name, type) {
  _classCallCheck(this, DecoratorMetaData);

  this.name = name;
  this.type = type;
};
/**
* JsonProperty
*
* @function
* @param {IDecoratorMetaData<T>|string} metadata Encapsulate it to DecoratorMetaData for standard use
* @return {(target: object, targetKey: string | symbol) => void} Decorator function
*/


exports.DecoratorMetaData = DecoratorMetaData;

function JsonProperty(metadata) {
  if (!['string', 'object'].some(function (value) {
    return _typeof(metadata) === value;
  })) {
    throw new Error('JsonProperty decorator options must be of type \'string\' or \'IDecoratorMetaData\'!');
  }

  var decorator = typeof metadata === 'string' ? new DecoratorMetaData(metadata) : metadata;
  return Reflect.metadata(METADATA_KEY, decorator);
}

function deserializeProp(metadata, instance, json, key) {
  var index = metadata.name || key;
  var value = json ? json[index] : null;
  var options = Reflect.getMetadata(METADATA_KEY, instance, key);
  var type = Reflect.getMetadata('design:type', instance, key) || options.type;

  if (type == undefined) {
    return json[index];
  }

  if (Array.isArray(type) || type === Array) {
    if (options && options.type || _typeof(type) === 'object') {
      if (value && Array.isArray(value)) {
        return value.map(function (item) {
          return deserialize(options.type, item);
        });
      }

      return;
    } else {
      return value;
    }
  }

  if (!isPrimitive(type) && _typeof(value) === 'object' && !Array.isArray(value)) {
    return deserialize(type, value);
  }

  if (type === Boolean) {
    if (json[index] === undefined) {
      return undefined;
    }

    return Boolean(json[index]);
  }

  return json[index];
}
/**
* deserialize
*
* @function
* @param {{new():T}} type, class type which is going to initialize and hold a mapping json
* @param {Object} json, input json object which to be mapped
*
* @return {T} return mapped object
*/


function deserialize(type, json) {
  if (type == undefined || json == undefined) {
    return undefined;
  }

  if (_typeof(json) !== 'object') {
    return undefined;
  }

  if (Array.isArray(json)) {
    return json.map(function (value) {
      return deserialize(type, value);
    });
  }

  var instance = new type();
  Object.keys(instance).forEach(function (key) {
    var metadata = Reflect.getMetadata(METADATA_KEY, instance, key);
    var value = metadata ? metadata.converter ? metadata.converter.fromJson(json[metadata.name || key]) : deserializeProp(metadata, instance, json, key) : json[key];
    instance[key] = value;
  });
  return instance;
}
/**
* Serialize: Creates a JSON serializable object from the provided object instance.
* Only @JsonProperty decorated properties in the model instance are processed.
*
*/


function serialize(instance) {
  if (Array.isArray(instance)) {
    return instance.map(function (value) {
      return serialize(value);
    });
  }

  var obj = Object.create(null);
  Object.keys(instance).forEach(function (key) {
    var metadata = Reflect.getMetadata(METADATA_KEY, instance, key);
    obj[metadata && metadata.name ? metadata.name : key] = serializeProperty(metadata, instance[key]);
  });
  return obj;
}
/**
* Prepare a single property to be serialized to JSON.
*
* @param metadata
* @param prop
* @returns {any}
*/


function serializeProperty(metadata, prop) {
  if (prop == undefined) {
    return prop;
  }

  if (!metadata || metadata.exclude === true) {
    return;
  }

  if (metadata.converter) {
    return metadata.converter.toJson(prop);
  }

  if (!metadata.type) {
    return prop instanceof Date ? new Date(prop.getTime() - prop.getTimezoneOffset() * 60000).toISOString() : prop;
  }

  if (Array.isArray(prop)) {
    return prop.map(function (item) {
      return serialize(item);
    });
  }

  return serialize(prop);
}

function isPrimitive(obj) {
  return !!(['string', 'boolean', 'number'].indexOf(_typeof(obj)) > -1 || obj instanceof String || obj === String || obj instanceof Number || obj === Number || obj instanceof Boolean || obj === Boolean);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC50cyJdLCJuYW1lcyI6WyJNRVRBREFUQV9LRVkiLCJEZWNvcmF0b3JNZXRhRGF0YSIsIm5hbWUiLCJ0eXBlIiwiSnNvblByb3BlcnR5IiwibWV0YWRhdGEiLCJzb21lIiwidmFsdWUiLCJFcnJvciIsImRlY29yYXRvciIsIlJlZmxlY3QiLCJkZXNlcmlhbGl6ZVByb3AiLCJpbnN0YW5jZSIsImpzb24iLCJrZXkiLCJpbmRleCIsIm9wdGlvbnMiLCJnZXRNZXRhZGF0YSIsInVuZGVmaW5lZCIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIml0ZW0iLCJkZXNlcmlhbGl6ZSIsImlzUHJpbWl0aXZlIiwiQm9vbGVhbiIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiY29udmVydGVyIiwiZnJvbUpzb24iLCJzZXJpYWxpemUiLCJvYmoiLCJjcmVhdGUiLCJzZXJpYWxpemVQcm9wZXJ0eSIsInByb3AiLCJleGNsdWRlIiwidG9Kc29uIiwiRGF0ZSIsImdldFRpbWUiLCJnZXRUaW1lem9uZU9mZnNldCIsInRvSVNPU3RyaW5nIiwiaW5kZXhPZiIsIlN0cmluZyIsIk51bWJlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7QUFZQTs7Ozs7QUFLQSxJQUFNQSxZQUFZLEdBQUcsY0FBckI7QUFFQTs7Ozs7O0FBeUJBOzs7Ozs7OztJQVFhQyxpQixHQUNYLDJCQUEwQkMsSUFBMUIsRUFBK0NDLElBQS9DLEVBQW9FO0FBQUE7O0FBQUE7QUFBQTtBQUNuRSxDO0FBR0g7Ozs7Ozs7Ozs7O0FBT08sU0FBU0MsWUFBVCxDQUF5QkMsUUFBekIsRUFBMEg7QUFDL0gsTUFBSSxDQUFDLENBQUMsUUFBRCxFQUFXLFFBQVgsRUFBcUJDLElBQXJCLENBQTBCLFVBQUFDLEtBQUs7QUFBQSxXQUFJLFFBQU9GLFFBQVAsTUFBb0JFLEtBQXhCO0FBQUEsR0FBL0IsQ0FBTCxFQUFvRTtBQUNsRSxVQUFNLElBQUlDLEtBQUosQ0FBVSxzRkFBVixDQUFO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c0IsUUFBdEIsRUFBZ0NVLE9BQWhDLFNBQWdEVixHQUFoRCxLQUF3RCxDQUFDLENBQXpELElBQStEQSxHQUFHLFlBQVlXLE1BQWYsSUFBeUJYLEdBQUcsS0FBS1csTUFBakMsSUFDekVYLEdBQUcsWUFBWVksTUFEMEQsSUFDaERaLEdBQUcsS0FBS1ksTUFEd0MsSUFFekVaLEdBQUcsWUFBWVAsT0FGMEQsSUFFL0NPLEdBQUcsS0FBS1AsT0FGMUIsQ0FBUjtBQUdEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdyZWZsZWN0LW1ldGFkYXRhJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSlNPTk9iamVjdCB7XHJcbiAgW2tleTogc3RyaW5nXTogSlNPTlR5cGU7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIEpTT05UeXBlID0gc3RyaW5nIHwgbnVtYmVyIHwgSlNPTkFycmF5IHwgSlNPTk9iamVjdCB8IGJvb2xlYW4gfCBudWxsO1xyXG5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbmV4cG9ydCBpbnRlcmZhY2UgSlNPTkFycmF5IGV4dGVuZHMgQXJyYXk8SlNPTlR5cGU+IHt9XHJcblxyXG5cclxuLyoqXHJcbiogRGVjb3JhdG9yIHZhcmlhYmxlIG5hbWVcclxuKlxyXG4qIEBjb25zdFxyXG4qL1xyXG5jb25zdCBNRVRBREFUQV9LRVkgPSAnSnNvblByb3BlcnR5JztcclxuXHJcbi8qKlxyXG4qIFdoZW4gY3VzdG9tIG1hcHBpbmcgb2YgYSBwcm9wZXJ0eSBpcyByZXF1aXJlZC5cclxuKlxyXG4qIEBpbnRlcmZhY2VcclxuKi9cclxuZXhwb3J0IGludGVyZmFjZSBJQ3VzdG9tQ29udmVydGVyPFQ+IHtcclxuICBmcm9tSnNvbihkYXRhOiBhbnkpOiBUO1xyXG4gIHRvSnNvbihkYXRhOiBUKTogYW55O1xyXG59XHJcblxyXG4vKipcclxuKiBJRGVjb3JhdG9yTWV0YURhdGE8VD5cclxuKiBEZWNvcmF0b3JDb25zdHJhaW50XHJcbipcclxuKiBAaW50ZXJmYWNlXHJcbiogQHByb3BlcnR5IHtJQ3VzdG9tQ29udmVydGVyfSBjdXN0b21Db252ZXJ0ZXIsIHdpbGwgYmUgdXNlZCBmb3IgbWFwcGluZyB0aGUgcHJvcGVydHksIGlmIHNwZWNpZmllZFxyXG4qIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXhjbHVkZVRvSnNvbiwgd2lsbCBleGNsdWRlIHRoZSBwcm9wZXJ0eSBmb3Igc2VyaWFsaXphdGlvbiwgaWYgdHJ1ZVxyXG4qL1xyXG5leHBvcnQgaW50ZXJmYWNlIElEZWNvcmF0b3JNZXRhRGF0YTxUPiB7XHJcbiAgbmFtZT86IHN0cmluZztcclxuICB0eXBlPzogeyBuZXcoKTogVCB9O1xyXG4gIGNvbnZlcnRlcj86IElDdXN0b21Db252ZXJ0ZXI8VD47XHJcbiAgZXhjbHVkZT86IGJvb2xlYW47XHJcbn1cclxuXHJcbi8qKlxyXG4qIERlY29yYXRvck1ldGFEYXRhXHJcbiogTW9kZWwgdXNlZCBmb3IgZGVjb3JhdGlvbiBwYXJhbWV0ZXJzXHJcbipcclxuKiBAY2xhc3NcclxuKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSwgaW5kaWNhdGUgd2hpY2gganNvbiBwcm9wZXJ0eSBuZWVkZWQgdG8gbWFwXHJcbiogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUsIGlmIHRoZSB0YXJnZXQgaXMgbm90IHByaW1pdGl2ZSB0eXBlLCBtYXAgaXQgdG8gY29ycmVzcG9uZGluZyBjbGFzc1xyXG4qL1xyXG5leHBvcnQgY2xhc3MgRGVjb3JhdG9yTWV0YURhdGE8VD4gaW1wbGVtZW50cyBJRGVjb3JhdG9yTWV0YURhdGE8VD4ge1xyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgbmFtZTogc3RyaW5nLCBwdWJsaWMgdHlwZT86IHsgbmV3KCk6IFQgfSkge1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiogSnNvblByb3BlcnR5XHJcbipcclxuKiBAZnVuY3Rpb25cclxuKiBAcGFyYW0ge0lEZWNvcmF0b3JNZXRhRGF0YTxUPnxzdHJpbmd9IG1ldGFkYXRhIEVuY2Fwc3VsYXRlIGl0IHRvIERlY29yYXRvck1ldGFEYXRhIGZvciBzdGFuZGFyZCB1c2VcclxuKiBAcmV0dXJuIHsodGFyZ2V0OiBvYmplY3QsIHRhcmdldEtleTogc3RyaW5nIHwgc3ltYm9sKSA9PiB2b2lkfSBEZWNvcmF0b3IgZnVuY3Rpb25cclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEpzb25Qcm9wZXJ0eTxUPihtZXRhZGF0YT86IElEZWNvcmF0b3JNZXRhRGF0YTxUPiB8IHN0cmluZyk6ICh0YXJnZXQ6IG9iamVjdCwgdGFyZ2V0S2V5OiBzdHJpbmcgfCBzeW1ib2wpID0+IHZvaWQge1xyXG4gIGlmICghWydzdHJpbmcnLCAnb2JqZWN0J10uc29tZSh2YWx1ZSA9PiB0eXBlb2YgbWV0YWRhdGEgPT09IHZhbHVlKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdKc29uUHJvcGVydHkgZGVjb3JhdG9yIG9wdGlvbnMgbXVzdCBiZSBvZiB0eXBlIFxcJ3N0cmluZ1xcJyBvciBcXCdJRGVjb3JhdG9yTWV0YURhdGFcXCchJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBkZWNvcmF0b3IgPSB0eXBlb2YgbWV0YWRhdGEgPT09ICdzdHJpbmcnID8gbmV3IERlY29yYXRvck1ldGFEYXRhPFQ+KG1ldGFkYXRhKSA6IG1ldGFkYXRhO1xyXG5cclxuICByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShNRVRBREFUQV9LRVksIGRlY29yYXRvcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlc2VyaWFsaXplUHJvcDxUPihtZXRhZGF0YTogSURlY29yYXRvck1ldGFEYXRhPGFueT4sIGluc3RhbmNlOiBULCBqc29uOiBKU09OT2JqZWN0LCBrZXk6IHN0cmluZyk6IGFueSB7XHJcbiAgY29uc3QgaW5kZXggPSBtZXRhZGF0YS5uYW1lIHx8IGtleTtcclxuICBjb25zdCB2YWx1ZTogSlNPTlR5cGUgPSBqc29uID8ganNvbltpbmRleF0gOiBudWxsO1xyXG5cclxuICBjb25zdCBvcHRpb25zOiBJRGVjb3JhdG9yTWV0YURhdGE8YW55PiA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoTUVUQURBVEFfS0VZLCBpbnN0YW5jZSwga2V5KTtcclxuICBjb25zdCB0eXBlOiBhbnkgPSBSZWZsZWN0LmdldE1ldGFkYXRhKCdkZXNpZ246dHlwZScsIGluc3RhbmNlLCBrZXkpIHx8IG9wdGlvbnMudHlwZTtcclxuXHJcbiAgaWYgKHR5cGUgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICByZXR1cm4ganNvbltpbmRleF07XHJcbiAgfVxyXG5cclxuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSB8fCB0eXBlID09PSBBcnJheSkge1xyXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBpZiAodmFsdWUgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUubWFwKChpdGVtOiBhbnkpID0+IGRlc2VyaWFsaXplKG9wdGlvbnMudHlwZSwgaXRlbSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICghaXNQcmltaXRpdmUodHlwZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgIHJldHVybiBkZXNlcmlhbGl6ZSh0eXBlLCB2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZSA9PT0gQm9vbGVhbikge1xyXG4gICAgaWYgKGpzb25baW5kZXhdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gQm9vbGVhbihqc29uW2luZGV4XSk7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBqc29uW2luZGV4XTtcclxufVxyXG5cclxuLyoqXHJcbiogZGVzZXJpYWxpemVcclxuKlxyXG4qIEBmdW5jdGlvblxyXG4qIEBwYXJhbSB7e25ldygpOlR9fSB0eXBlLCBjbGFzcyB0eXBlIHdoaWNoIGlzIGdvaW5nIHRvIGluaXRpYWxpemUgYW5kIGhvbGQgYSBtYXBwaW5nIGpzb25cclxuKiBAcGFyYW0ge09iamVjdH0ganNvbiwgaW5wdXQganNvbiBvYmplY3Qgd2hpY2ggdG8gYmUgbWFwcGVkXHJcbipcclxuKiBAcmV0dXJuIHtUfSByZXR1cm4gbWFwcGVkIG9iamVjdFxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemU8VCwgVSBleHRlbmRzIEpTT05PYmplY3QgfCBKU09OQXJyYXkgPSBKU09OT2JqZWN0Pih0eXBlOiB7IG5ldygpOiBUIH0sIGpzb246IFUpOiBVIGV4dGVuZHMgSlNPTk9iamVjdCA/IFQgOiBUW107XHJcbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZTxUPih0eXBlOiB7IG5ldygpOiBUIH0sIGpzb246IEpTT05PYmplY3QgfCBKU09OQXJyYXkpOiBUIHwgVFtdIHtcclxuICBpZiAodHlwZSA9PSB1bmRlZmluZWQgfHwganNvbiA9PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGpzb24gIT09ICdvYmplY3QnKSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHtcclxuICAgIHJldHVybiBqc29uLm1hcCgodmFsdWU6IEpTT05PYmplY3QpID0+IGRlc2VyaWFsaXplKHR5cGUsIHZhbHVlKSk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBpbnN0YW5jZSA9IG5ldyB0eXBlKCk7XHJcbiAgXHJcbiAgT2JqZWN0LmtleXMoaW5zdGFuY2UpLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiB7XHJcbiAgICBjb25zdCBtZXRhZGF0YTogSURlY29yYXRvck1ldGFEYXRhPFQ+ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShNRVRBREFUQV9LRVksIGluc3RhbmNlLCBrZXkpO1xyXG5cclxuICAgIGNvbnN0IHZhbHVlID0gbWV0YWRhdGEgPyBtZXRhZGF0YS5jb252ZXJ0ZXIgPyBtZXRhZGF0YS5jb252ZXJ0ZXIuZnJvbUpzb24oanNvblttZXRhZGF0YS5uYW1lIHx8IGtleV0pIDogZGVzZXJpYWxpemVQcm9wKG1ldGFkYXRhLCBpbnN0YW5jZSwganNvbiwga2V5KSA6IGpzb25ba2V5XTtcclxuXHJcbiAgICBpbnN0YW5jZVtrZXldID0gdmFsdWU7ICAgIFxyXG4gIH0pO1xyXG4gIFxyXG4gIHJldHVybiBpbnN0YW5jZTtcclxufVxyXG5cclxuLyoqXHJcbiogU2VyaWFsaXplOiBDcmVhdGVzIGEgSlNPTiBzZXJpYWxpemFibGUgb2JqZWN0IGZyb20gdGhlIHByb3ZpZGVkIG9iamVjdCBpbnN0YW5jZS5cclxuKiBPbmx5IEBKc29uUHJvcGVydHkgZGVjb3JhdGVkIHByb3BlcnRpZXMgaW4gdGhlIG1vZGVsIGluc3RhbmNlIGFyZSBwcm9jZXNzZWQuXHJcbipcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZTxUIGV4dGVuZHMgb2JqZWN0ID0gYW55LCBVIGV4dGVuZHMgb2JqZWN0ID0gYW55PihpbnN0YW5jZTogVCB8IFRbXSk6IFQgZXh0ZW5kcyBhbnlbXSA/IFVbXSA6IFU7XHJcbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemU8VCBleHRlbmRzIG9iamVjdCA9IGFueSwgVSBleHRlbmRzIG9iamVjdCA9IGFueT4oaW5zdGFuY2U6IFQgfCBUW10pOiBVIHwgVVtdIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShpbnN0YW5jZSkpIHtcclxuICAgIHJldHVybiBpbnN0YW5jZS5tYXAoKHZhbHVlOiBUKSA9PiBzZXJpYWxpemUodmFsdWUpKTtcclxuICB9XHJcbiAgXHJcbiAgY29uc3Qgb2JqOiBVID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICBPYmplY3Qua2V5cyhpbnN0YW5jZSkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgY29uc3QgbWV0YWRhdGE6IElEZWNvcmF0b3JNZXRhRGF0YTxUPiA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoTUVUQURBVEFfS0VZLCBpbnN0YW5jZSwga2V5KTtcclxuICAgIG9ialttZXRhZGF0YSAmJiBtZXRhZGF0YS5uYW1lID8gbWV0YWRhdGEubmFtZSA6IGtleV0gPSBzZXJpYWxpemVQcm9wZXJ0eShtZXRhZGF0YSwgaW5zdGFuY2Vba2V5XSk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4qIFByZXBhcmUgYSBzaW5nbGUgcHJvcGVydHkgdG8gYmUgc2VyaWFsaXplZCB0byBKU09OLlxyXG4qXHJcbiogQHBhcmFtIG1ldGFkYXRhXHJcbiogQHBhcmFtIHByb3BcclxuKiBAcmV0dXJucyB7YW55fVxyXG4qL1xyXG5mdW5jdGlvbiBzZXJpYWxpemVQcm9wZXJ0eShtZXRhZGF0YTogSURlY29yYXRvck1ldGFEYXRhPGFueT4sIHByb3A6IGFueSk6IGFueSB7XHJcbiAgaWYgKHByb3AgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICByZXR1cm4gcHJvcDtcclxuICB9XHJcbiAgXHJcbiAgaWYgKCFtZXRhZGF0YSB8fCBtZXRhZGF0YS5leGNsdWRlID09PSB0cnVlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChtZXRhZGF0YS5jb252ZXJ0ZXIpIHtcclxuICAgIHJldHVybiBtZXRhZGF0YS5jb252ZXJ0ZXIudG9Kc29uKHByb3ApO1xyXG4gIH1cclxuICBcclxuICBpZiAoIW1ldGFkYXRhLnR5cGUpIHtcclxuICAgIHJldHVybiBwcm9wIGluc3RhbmNlb2YgRGF0ZSA/IG5ldyBEYXRlKHByb3AuZ2V0VGltZSgpIC0gKHByb3AuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwKSkudG9JU09TdHJpbmcoKSA6IHByb3A7XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChBcnJheS5pc0FycmF5KHByb3ApKSB7XHJcbiAgICByZXR1cm4gcHJvcC5tYXAoKGl0ZW06IGFueSkgPT4gc2VyaWFsaXplKGl0ZW0pKTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHNlcmlhbGl6ZShwcm9wKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNQcmltaXRpdmUob2JqOiB1bmtub3duKTogb2JqIGlzIHN0cmluZyB8IGJvb2xlYW4gfCBudW1iZXIgfCBOdW1iZXJDb25zdHJ1Y3RvciB8IFN0cmluZ0NvbnN0cnVjdG9yIHwgQm9vbGVhbkNvbnN0cnVjdG9yIHtcclxuICByZXR1cm4gISEoWydzdHJpbmcnLCAnYm9vbGVhbicsICdudW1iZXInXS5pbmRleE9mKCh0eXBlb2Ygb2JqKSkgPiAtMSB8fCAob2JqIGluc3RhbmNlb2YgU3RyaW5nIHx8IG9iaiA9PT0gU3RyaW5nIHx8XHJcbiAgb2JqIGluc3RhbmNlb2YgTnVtYmVyIHx8IG9iaiA9PT0gTnVtYmVyIHx8XHJcbiAgb2JqIGluc3RhbmNlb2YgQm9vbGVhbiB8fCBvYmogPT09IEJvb2xlYW4pKTtcclxufVxyXG4iXX0=